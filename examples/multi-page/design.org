* Some multi-page design thoughts:
** Design thoughts
- we want to be able to clear up state appropriately from the global
  state map, when it falls out of scope.
  - how does one go about defining 'when state falls out of scope'?
    e.g. in StoreBuilder, 'component local' state needs to persist
    across a number of views/handlers (I think?!).
- we're keeping this state in the global map to begin with to make it
  easy to access (do we have to keep things global to make them
  accessible?)
- we want to solve the 'component inversion' problem, where a page
  declares its content within an outer container (e.g. a page
  template)
- this needs to work across browser history state changes - which
  likely come to us independently of any other events.
** Possible solutions
- we could create a map at the top level, from Bidi handler key ->
  collection of mount/unmount/view functions, similar to what React
  has already (except decoupled from the /actual/ React lifecycle,
  because Figwheel reloads.
  - this doesn't solve the 'component inversion' very well, I don't
    think.

** Possible API
#+BEGIN_SRC clojure
  (defprotocol Router
    (set-path! [_ {:keys [handler route-params query-params]}])
    (replace-path! [_ {:keys [handler route-params query-params]}])

    (current-location [_]))

  (defprotocol TokenMapper
    (token->location [_ token])
    (location->token [_ {:keys [handler route-params query-params]}]))

  {:router (-> (fn []
                 (router/make-router {:token-mapper (bidi-mapper/token-mapper bidi-routes)
                                      :listener #(reset! (r/cursor (bc/ask :!app-state) [::root-component]) %)

                                      :pages {::home-page (fn [{:keys [old-location new-location same-handler?]}]
                                                            ;; mount
                                                            (router/->page value
                                                                           (fn [{:keys [old-location new-location same-handler?]}]
                                                                             ;; unmount
                                                                             )))

                                              ::page-two (fn [{:keys [old-location new-location same-handler?]}]
                                                           ;; mount
                                                           (router/->page value
                                                                          (fn [{:keys [old-location new-location same-handler?]}]
                                                                            ;; unmount
                                                                            )))}}))
               (bc/using #{:!app-state}))

   :renderer (-> (fn []
                   (bc/->component (r/render-component (fn []
                                                         @(r/cursor (bc/ask :!app-state) [::root-component]))

                                                       js/document.body)
                                   (fn []
                                     (r/render-component nil js/document.body))))

                 (bc/using #{:!app-state}))}
#+END_SRC
